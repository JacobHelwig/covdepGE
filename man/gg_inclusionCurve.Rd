% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gg_covdepGE.R
\name{gg_inclusionCurve}
\alias{gg_inclusionCurve}
\title{gg_inclusionCurve}
\usage{
gg_inclusionCurve(
  out,
  col_idx1,
  col_idx2,
  line_type = "solid",
  line_size = 0.5,
  line_color = "black",
  point_shape = 21,
  point_size = 1.5,
  point_color = "#500000",
  point_fill = "white",
  sort = F
)
}
\arguments{
\item{out}{\code{list}; return of \code{covdepGE} function}

\item{col_idx1}{scalar in \eqn{{1, 2, ..., p + 1}}; column index of the first
variable}

\item{col_idx2}{scalar in \eqn{{1, 2, ..., p + 1}}; column index of the
second variable}

\item{line_type}{scalar; \code{ggplot2} line type to interpolate the
probabilities. \code{"solid"} by default}

\item{line_size}{scalar in \eqn{(0, Inf)}; thickness of the interpolating
line. \code{0.5} by default}

\item{line_color}{scalar; color of interpolating line. \code{"black"} by default}

\item{point_shape}{scalar; shape of the points denoting individual-specific
inclusion probabilities; \code{21} by default}

\item{point_size}{scalar in \eqn{(0, Inf)}; size of probability points. \code{1.5}
by default}

\item{point_color}{scalar; color of probability points. \code{"#500000"} by
default}

\item{point_fill}{scalar; fill of probability points. Only applies to select
shapes. \code{"white"} by default}

\item{sort}{logical scalar; if \code{T}, applies a piori sorting algorithm to
re-order subject indices according to weights such for \eqn{j} in
\eqn{1,...,n - 1}, subject \eqn{j + 1} is the most similar in terms of their
extraneous covariate to subject \eqn{j}. Helps visualize the continuity
with which the edge probabilities are modeled with respect to the the
extraneous covariates}
}
\value{
Returns \code{ggplot2} visualization of inclusion probability curve
}
\description{
Create a visualization of the probabilities of inclusion of an
edge between two variables across all \eqn{n} individuals
}
\examples{
set.seed(1)
n <- 100
p <- 4

# generate the extraneous covariate
Z_neg <- sort(runif(n / 2) * -1)
Z_pos <- sort(runif(n / 2))
Z <- c(Z_neg, Z_pos)
summary(Z)

# create true covariance structure for 2 groups: positive Z and negative Z
true_graph_pos <- true_graph_neg <- matrix(0, p + 1, p + 1)
true_graph_pos[1, 2] <- true_graph_pos[2, 1] <- 1
true_graph_neg[1, 3] <- true_graph_neg[3, 1] <- 1

# visualize the true covariance structures
(gg_adjMat(true_graph_neg) +
    ggplot2::ggtitle("True graph for individuals with negative Z"))
(gg_adjMat(true_graph_pos, color1 = "steelblue") +
    ggplot2::ggtitle("True graph for individuals with positive Z"))

# generate the covariance matrices as a function of Z
sigma_mats_neg <- lapply(Z_neg, function(z) z * true_graph_neg + diag(p + 1))
sigma_mats_pos <- lapply(Z_pos, function(z) z * true_graph_pos + diag(p + 1))
sigma_mats <- c(sigma_mats_neg, sigma_mats_pos)

# generate the data using the covariance matrices
data_mat <- t(sapply(sigma_mats, MASS::mvrnorm, n = 1, mu = rep(0, p + 1)))

# visualize the sample correlation
gg_adjMat(abs(cor(data_mat[1:(n / 2), ])) - diag(p + 1))
gg_adjMat(abs(cor(data_mat[(n / 2 + 1):n, ])) - diag(p + 1),
          color1 = "dodgerblue")

# estimate the covariance structure
out <- covdepGE(data_mat, Z)

# analyze results
gg_adjMat(out, 1)
gg_adjMat(out, 50, color1 = "tomato")
gg_adjMat(out, 54, color1 = "steelblue")
gg_adjMat(out, 100, color1 = "dodgerblue")

gg_inclusionCurve(out, 1, 2)
gg_inclusionCurve(out, 1, 3, point_color = "dodgerblue")
}
