---
title: "KDE-debugging-demo"
output: pdf_document
---

```{r, include = F}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 65), tidy = TRUE)
```


```{r}
# takes a n x 1 vector of data
# calculates silverman's rule of thumb for sigma
# https://github.com/statsmodels/statsmodels/blob/main/statsmodels/nonparametric/bandwidths.py
silverman <- function(x){

  # apply and return silverman's rule of thumb
  sigma <- (0.9 * min(sd(x), IQR(x) / 1.35) * length(x)^(-0.2))
  return(sigma)
}

# takes a point z, a vector of n means, and scalar sigma
# returns the density of z under the density of a mixture of Gaussians, each
# centered at mu with standard deviation sigma
phi0_k.z <- function(z, mu, sigma){

  # calculate and return the density of z
  return((1 / length(mu)) * sum(dnorm(z, mu, sigma)))
}

# vectorized version of phi0_k - takes a vector Z of length N, vector of n means
# and a scalar sigma
# Returns a vector of N densities
phi0_k <- function(Z, mu, sigma){
  return(sapply(Z, phi0_k.z, mu = mu, sigma = sigma))
}

# function that takes a data matrix X and returns a bandwidth for each of the 
# subjects (vector of length n)
get_bandwidths <- function(X){
  
  # get dimensions of X
  n <- nrow(X)
  p <- ncol(X)

  # find the component-wise density for each of the individuals 
  # also find silverman's rule of thumb for each of the columns of X 
  densities <- matrix(NA, n, p)
  sigma <- rep(NA, p)
  for (j in 1:p){
    
    # find the value of sigma corresponding to the j-th predictor
    sigma[j] <- silverman(X[ , j])
    
    # calculate the resulting densities
    densities[ , j] <- phi0_k(X[ , j], X[ , j], sigma[j])
  }
  
  # calculate the harmonic mean for the sigma^2
  H <- 1 / mean(1 / sigma)
  
  # calculate the square root of the row-wise product of the densities
  rowProds_sqrt <- rep(NA, n)
  for (l in 1:n){
    rowProds_sqrt[l] <- prod(sqrt(densities[l, ]))  
  }
  
  # return the final bandwidths
  return(H / rowProds_sqrt)
}

```

```{r}
# generate some data and try it out
set.seed(1)
n <- 2000
p <- 5
limits <- matrix(1:p, p, 2) * matrix(c(-1, 1), p, 2, T)
X <- matrix(runif(n * p, limits[ , 1], limits[ , 2]), n , p, T)
summary(X)

# demo the functions:
library(ggplot2) 

# silverman rule of thumb for each column of X:
apply(X, 2, silverman)

# different n to try
(n_j <- seq(200, n, 200))

# matrices for storing quantiles and bandwidths
bandwidth.dist <- matrix(NA, 3, length(n_j))
colnames(bandwidth.dist) <- paste("n =", n_j)
rownames(bandwidth.dist) <- c("0.025", "0.5", "0.975")
bandwidths <- vector("list", length(n_j))

# plot the distribution of the bandwidths for varying p
bandwidth_dist_graph <- ggplot()

for (j in 1:length(n_j)){
  bandwidths[[j]] <- get_bandwidths(X[1:n_j[j], ])
  bandwidth.dist[ , j] <- quantile(bandwidths[[j]], c(0.025, 0.5, 0.975))
  bandwidth_dist_graph <- bandwidth_dist_graph + geom_point(data = cbind.data.frame(n = n_j[j], bandwidths = bandwidths[[j]]), aes(n, bandwidths), size = 0.5, color = "gray55", alpha = 0.3)
}  

bandwidth_dist_graph + theme_bw() + geom_line(data = data.frame(n = n_j, bandwidths = bandwidth.dist[1, ]), aes(n, bandwidths), color = "tomato2", linetype = "dotted") + geom_line(data = data.frame(n = n_j, bandwidths = bandwidth.dist[3, ]), aes(n, bandwidths), color = "tomato2", linetype = "dotted") + geom_line(data = data.frame(n = n_j, bandwidths = bandwidth.dist[2, ]), aes(n, bandwidths), color = "cyan") + scale_x_continuous(labels = n_j, breaks = n_j)

bandwidth.dist


```
<!--
# univariate KDE demo

(sigma.5 <- silverman(X[, 5]))

# apply univariate KDE:
ggplot() + xlim(-7, 7) + geom_histogram(data = data.frame(x = X[ , 5]), aes(x, y = ..density..), alpha = 0.2, bins = 40) + stat_function(fun = function(x) phi0_k(Z = x, mu = X[ , 5], sigma = sigma.5), color = "forestgreen", size = 1) + theme_bw()

# density integrates to 1
integrate(phi0_k, mu = X[ , 5], sigma = sigma.5, -Inf, Inf)

-->


<!--
# for varying p

# matrices for storing quantiles and bandwidths
bandwidth.dist <- matrix(NA, 3, p)
colnames(bandwidth.dist) <- paste("n =", 1:5)
rownames(bandwidth.dist) <- c("0.025", "0.5", "0.975")
bandwidths <- matrix(NA, n, p)

# plot the distribution of the bandwidths for varying p
bandwidth_dist_graph <- ggplot()

for (j in 1:p){
  bandwidths[ , j] <- get_bandwidths(X[ , 1:j, drop = F])
  bandwidth.dist[ , j] <- quantile(bandwidths[ , j], c(0.025, 0.5, 0.975))
  bandwidth_dist_graph <- bandwidth_dist_graph + geom_point(data = cbind.data.frame(p = j, bandwidths = bandwidths[ , j]), aes(p, bandwidths), size = 0.5, color = "gray55", alpha = 0.3)
}  

bandwidth_dist_graph + theme_bw() + geom_line(data = data.frame(p = 1:p, bandwidths = bandwidth.dist[1, ]), aes(p, bandwidths), color = "tomato2", linetype = "dotted") + geom_line(data = data.frame(p = 1:p, bandwidths = bandwidth.dist[3, ]), aes(p, bandwidths), color = "tomato2", linetype = "dotted") + geom_line(data = data.frame(p = 1:p, bandwidths = bandwidth.dist[2, ]), aes(p, bandwidths), color = "cyan")

bandwidth.dist
```
-->

<!--
# small data demo

# DEMO

# smaller sample for explicit calculations 
set.seed(1)
X <- cbind(runif(3, 2, 5), runif(3, -3, 1))
X
(bw <- get_bandwidths(X))

# manual calculations

# calculate Silverman for both columns
(silv1 <- 0.9 * min(sd(X[ , 1]), IQR(X[ , 1]) / 1.35) * nrow(X)^-0.2)
(silv2 <- 0.9 * min(sd(X[ , 2]), IQR(X[ , 2]) / 1.35) * nrow(X)^-0.2)

# calculate the harmonic mean 
(h <- ncol(X) / ((1 / silv1) + (1 / silv2)))

# calculate the square root of the product of the step 1 densities for 
# each individual

# individual 1

# sum and normalize the densities for both columns
(dens11 <- 1 / nrow(X) * sum(dnorm(X[1, 1], X[ , 1], silv1)))
(dens12 <- 1 / nrow(X) * sum(dnorm(X[1, 2], X[ , 2], silv2)))

# get the root of the product of the densities
(dens1 <- sqrt(dens11 * dens12))

# individual 2

# sum and normalize the densities for both columns
(dens21 <- 1 / nrow(X) * sum(dnorm(X[2, 1], X[ , 1], silv1)))
(dens22 <- 1 / nrow(X) * sum(dnorm(X[2, 2], X[ , 2], silv2)))

# get the root of the product of the densities
(dens2 <- sqrt(dens21 * dens22))

# individual 3

# sum and normalize the densities for both columns
(dens31 <- 1 / nrow(X) * sum(dnorm(X[3, 1], X[ , 1], silv1)))
(dens32 <- 1 / nrow(X) * sum(dnorm(X[3, 2], X[ , 2], silv2)))

# get the root of the product of the densities
(dens3 <- sqrt(dens31 * dens32))

# final bandwidths:
dens <- c(dens1, dens2, dens3)
(bw.manual <- h / dens)

bw.manual - bw
```
-->

