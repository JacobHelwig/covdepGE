---
title: "parallelization-demo"
output: pdf_document
---

# Data generation

```{r, fig.width = 11, fig.height = 9}
library(covdepGE)
library(ggpubr)
library(ggplot2)

setwd("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/dev")
source("generate_data.R")
cont <- generate_continuous()
data_mat <- cont$data
dim(data_mat)
Z <- cont$covts

# get all of the unique graphs from the data and visualize them
true_graphs <- lapply(cont$true_precision, function(prec_mat) (prec_mat != 0) 
                      - diag(nrow(prec_mat)))
tr_gr_uq <- unique(true_graphs)
indv_gr <- lapply(tr_gr_uq, function(unique_graph) which(sapply(
  true_graphs, function(graph) identical(graph, unique_graph))))
indv_gr_sum <- sapply(indv_gr, function(idx_seq) paste0(min(idx_seq), ",...,", 
                                                        max(idx_seq)))
colors <- c("steelblue", "goldenrod", "forestgreen", "tomato2", 
            "dodgerblue", "darkorchid")
graph_viz <- lapply(1:length(tr_gr_uq), function(gr_idx) gg_adjMat(
  tr_gr_uq[[gr_idx]], color1 = colors[gr_idx]) + 
    ggtitle(paste("Individuals", indv_gr_sum[gr_idx])))
annotate_figure(ggarrange(plotlist = graph_viz), 
                top = text_grob("True Conditional Dependence Structures", 
                                size = 15))
```

# Parallel Variational Updates

Setting `parallel = T` in a call to `covdepGE` performs the variational updates for responses in parallel to one another. Parallel backend may be registered manually by the user, but will otherwise be done automatically. This allows flexibility for the user to configure the parallelization according to their needs.

## Manual parallel backend registration:

```{r}
# record time to register parallel backend
start <- Sys.time()
doParallel::registerDoParallel(5)
Sys.time() - start

# run covdepGE in parallel
covdepGE(data_mat, Z, parallel = T, n_sigma = 5)
```

## Automatic parallel backend registration

```{r}
covdepGE(data_mat, Z, parallel = T, num_workers = 7, stop_cluster = F, n_sigma = 5)
```

By setting `stop_cluster = F`, subsequent parallel calls to `covdepGE` are able to employ the same workers. This avoids the overhead of creating a new cluster.

# Efficiency

## Large number of candidates

The model in the previous section was relatively simple, with only 5 candidates. In this case, the time to create the cluster, distribute the tasks, and communication from the parent to the children workers outweighs the time savings of parallelizing the updates. Thus, sequential execution is faster for this small model.

```{r}
covdepGE(data_mat, Z, n_sigma = 5)
```

However, for a more complex model, the benefits of parallelization become apparent. To increase complexity, I will increase the number of candidate models to 200. 

```{r}
# sequential
out_seq <- covdepGE(data_mat, Z, n_sigma = 200)
out_seq

# parallel
out_par <- covdepGE(data_mat, Z, n_sigma = 200, parallel = T, 
                    num_workers = 6)
out_par
```

The parallel model outperforms the sequential - additionally, the models produce identical results.

Note the message displayed by the parallel model - it has detected that there are workers on an active cluster from the parallel model with `stop_cluster = F` above. It ignores the `num_workers` argument and re-uses the detected cluster. 

```{r, fig.width = 11, fig.height = 9}
annotate_figure(ggarrange(plotlist = plot(out_seq, graph_colors = colors)), 
                top = text_grob("Unique Graphs, Sequential Execution", size = 15))
annotate_figure(ggarrange(plotlist = plot(out_par, colors)), 
                top = text_grob("Unique Graphs, Parallel Execution", size = 15))
```

## Large *n*

An increase in complexity can also be achieved by again choosing the number of candidate models to be 5 and increasing the sample size. Again, the parallellized updates beat the sequential updates while producing the same result. 

```{r, fig.width = 11, fig.height = 9} 
sz <- 200
cont <- generate_continuous(n1 = sz, n2 = sz, n3 = sz)
data_mat <- cont$data
dim(data_mat)
Z <- cont$covts

# get all of the unique graphs from the data and visualize them
true_graphs <- lapply(cont$true_precision, function(prec_mat) (prec_mat != 0) 
                      - diag(nrow(prec_mat)))
tr_gr_uq <- unique(true_graphs)
indv_gr <- lapply(tr_gr_uq, function(unique_graph) which(sapply(
  true_graphs, function(graph) identical(graph, unique_graph))))
indv_gr_sum <- sapply(indv_gr, function(idx_seq) paste0(min(idx_seq), ",...,", 
                                                        max(idx_seq)))
graph_viz <- lapply(1:length(tr_gr_uq), function(gr_idx) gg_adjMat(
  tr_gr_uq[[gr_idx]], color1 = colors[gr_idx]) + 
    ggtitle(paste("Individuals", indv_gr_sum[gr_idx])))
annotate_figure(ggarrange(plotlist = graph_viz), 
                top = text_grob("True Conditional Dependence Structures", 
                                size = 15))
```

Note that since the last parallel call to `covdepGE` did not specify `stop_cluster = F`, the cluster must be re-created.

```{r, fig.width = 11, fig.height = 7}
# sequential
out_seq <- covdepGE(data_mat, Z, n_sigma = 5)
out_seq

# parallel
out_par <- covdepGE(data_mat, Z, n_sigma = 5, parallel = T, num_workers = 8)
out_par

annotate_figure(ggarrange(plotlist = plot(out_seq, colors)), 
                top = text_grob("Unique Graphs, Sequential Execution", size = 15))
annotate_figure(ggarrange(plotlist = plot(out_par, colors)), 
                top = text_grob("Unique Graphs, Parallel Execution", size = 15))
```
