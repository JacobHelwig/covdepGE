---
title: "MAPE Updates, v1"
output: pdf_document
---

# Overview

In this implementation of `covdepGE`, the variance hyperparameters for each model are optimized after each CAVI update using MAPE. The value of the prior inclusion probability for each variable is chosen from a grid of the following values:

\[\pi\in\{0.450, 0.295, 0.193, 0.127, 0.083, 0.054, 0.036, 0.023, 0.015, 0.010\}\]

The data is the usual continuous example with the distribution of the extraneous covariate and the true precision matrices as below.

```{r, echo = F, include = F}
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_main.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/cavi_search.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/weights.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/checks.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/gg_covdepGE.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_R.R")
Rcpp::sourceCpp("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/src/covdepGE_c.cpp")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/dev/generate_data.R")

dat <- generate_continuous()
data_mat <- dat$data
Z <- dat$covts
n <- nrow(data_mat)
```

```{r, echo = F, fig.height = 4.5, fig.width = 11}
library(ggplot2)
library(reshape2)

covt_df <- data.frame(Interval = factor(rep(1:3, each = 60)), Z = Z)
ggplot() + 
  geom_histogram(data = covt_df, aes(Z, fill = Interval), color = "black", bins = n %/% 5) + 
  ggtitle("Distribution of Extraneous Covariate") + 
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  ggsci::scale_fill_jama()
```

```{r, echo = F, fig.height = 9, fig.width = 11}
unique_prec <- unique(lapply(dat$true_precision, function(graph) ((graph - diag(diag(graph))) != 0) * 1))
titles <- paste("Individuals", c("1,...,60", "61,...,120", "121,...,180"))
prec_mats <- lapply(1:length(unique_prec), function(
  graph_ind) gg_adjMat(unique_prec[[graph_ind]]) + ggtitle(titles[graph_ind]))
ggpubr::ggarrange(plotlist = prec_mats)
```

The results of a less flexible graphical modeling method are also presented.

# Graphical Modeling Results

The graphs produced by the MAPE-updated `covdepGE` and the alternative method are very similar. 

## MAPE-updated `covdepGE`

```{r, echo = F, fig.height = 9, fig.width = 11}
out <- covdepGE(data_mat, Z, R = T, max_iter_grid = 10, max_iter_final = 10, 
                  warnings = F)

ggpubr::ggarrange(plotlist = plot(out, title_sum = T))
```

## Alternative `covdepGE`

In the alternative method, the slab variance is chosen by maximizing ELBO over a grid and the error term variance and prior inclusion probabilities are selected using `varbvs`. $\pi$ is simply the mean over a grid generated a priori by `varbvs`, while `sigma^2` is the mean over a range of `sigma^2` fit to the data for each grid point in the grid of $\pi$ values.

```{r, echo = F, fig.height = 9, fig.width = 11}
out2 <- covdepGE(data_mat, Z, sigmabetasq_vec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10), 
                 R = F, max_iter_final = 10, max_iter_grid = 10, update_sigmabetasq = F,
                 update_sigmasq = F, warnings = F)
ggpubr::ggarrange(plotlist = plot(out2, title_sum = T))
```

# Hyperparameter Analysis

Below is a visualization of the fitted variance hyperparameter values by individual, as well as the prior inclusion probabilities values chosen for each variable. Note that although the variance hyperparameters are fit for each individual, the prior inclusion probabilities are chosen for each variable by maximizing the sum of the ELBO across all individuals. 

Observe that for variables 1, 2 and 3, the chosen value of $\pi$ is greater than for variables 4 and 5. This is presumably because the conditional dependencies in the data involve variables 1, 2 and 3. However, since the conditional dependencies only involve a subset of the individuals, it could be beneficial to optimize $\pi$ for each individual. That is, since, for example, the (1, 3) entry is non-zero only for individuals 61,...,180, choosing $\pi$ by maximizing ELBO on the individual level could allow for a greater $\pi$ for these individuals, and a lesser $\pi$ for individuals 1,...,60. 

```{r, echo = F}
sigmasq <- melt(out$hyperparameters$sigmasq, varnames = c("Individual", "Variable"), value.name = "sigmasq")
ggplot() + 
  geom_line(data = sigmasq, aes(Individual, sigmasq, color = Variable), size = 1) + 
  ggsci::scale_color_jco() +
  theme_bw() + 
  ggtitle("Fitted error term variance by variable") + 
  theme(plot.title = element_text(hjust = 0.5))

sigmabetasq <- melt(out$hyperparameters$sigmabetasq, varnames = c("Individual", "Variable"), value.name = "sigmabetasq")
ggplot() + 
  geom_line(data = sigmabetasq, aes(Individual, sigmabetasq, color = Variable), size = 1) + 
  ggsci::scale_color_nejm() +
  theme_bw() + 
  ggtitle("Fitted slab variance by variable") + 
  theme(plot.title = element_text(hjust = 0.5))

ggplot() + geom_bar(data = data.frame(Variable = names(out$hyperparameters$pi), 
                                      pi = out$hyperparameters$pi), aes(Variable, pi, fill = Variable), stat = "identity") + 
  ggsci::scale_fill_uchicago() + 
  theme_bw() + 
  ggtitle("Pi value by variable") + 
  theme(plot.title = element_text(hjust = 0.5))
```

Finally, the raw hyperparameter values are included.

```{r, echo = F}
lapply(out$hyperparameters, round, 4)
```
