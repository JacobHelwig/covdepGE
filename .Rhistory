strs <- unique(true_graphs)
# get the individual indices corresponding to each of the structures
ind_idx <- lapply(strs, function(strc) which(sapply(true_graphs, identical, strc)))
# get the summary for each
ind_sum <- sapply(ind_idx, function(idx) paste0(min(idx), ",...,", max(idx)))
# visualize each of the structures
str_viz <- lapply(1:length(strs), function(strc_idx)
gg_adjMat(strs[[strc_idx]], color1 = colors[strc_idx]) +
ggtitle(paste("Individuals ", ind_sum[strc_idx])))
ggarrange(plotlist = str_viz)
X2 <- cbind(X[ , 15], X[ , -15])
dim(X2)
dim(X)
debug(covdepGE)
# run the algorithm
out <- covdepGE(X, Z, max_iter = 1e3, parallel = T, num_workers = 15, warnings = F)
out <- covdepGE(X, Z, max_iter = 1e3, parallel = F, num_workers = 15, warnings = F)
out$elbo
out$pi
out$sigmasq
out$pi
out <- covdepGE(X2, Z, max_iter = 1e3, parallel = F, num_workers = 15, warnings = F)
out$elbo
out$pi
sigmasq_vec
out$pi
out$elbo
undebug(covdepGE)
# run the algorithm
out <- covdepGE(X, Z, max_iter = 1e3, parallel = T, num_workers = 15, warnings = F)
out
# which of the sigmas blew up?
blown_sigs <- out$hyperparameters$sigmasq > 10 | is.na(out$hyperparameters$sigmasq)
# find the total number of blownup sigmas per variable
blown_by_var <- colSums(blown_sigs)
# which variables have at least one blown up sigma?
blown_vars <- which(blown_by_var > 0)
# find the blown up counts that are greater than 0
blown0_ct <- blown_by_var[blown_vars]
# find the individual indices corresponding to the blown up sigmas
blown_inds <- apply(blown_sigs[ , blown_vars, drop = F], 2, which)
blown_vars
# visualize condition numbers and bandwidths
cov_df$cond_nums <- lapply(blown_vars, function(idx) sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p))))
cov_df$cond_nums
blown_vars
idx = 15
sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p)))
blown_vars
as.numeric(blown_vars)
# visualize condition numbers and bandwidths
cov_df$cond_nums <- sapply(as.numeric(blown_vars), function(idx) sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p))))
cov_df$cond_nums
# visualize condition numbers and bandwidths
cov_df$cond_nums <- sapply((blown_vars), function(idx) sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p))))
cov_df$cond_nums
lapply((blown_vars), function(idx) sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p))))
# visualize condition numbers and bandwidths
cond_nums <- lapply((blown_vars), function(idx) sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p))))
start <- Sys.time()
# function for generating the data and the covariates
generate_continuous <- function(n1 = 60, n2 = 60, n3 = 60, p = 4){
# create covariate for individuals in each of the three intervals
# define the dimensions of the data
n <- sum(n1, n2, n3)
# define the limits of the intervals
limits1 <- c(-3, -1)
limits2 <- c(-1, 1)
limits3 <- c(1, 3)
# define the covariate values within each interval
z1 <- runif(n1, limits1[1], limits1[2])
z2 <- runif(n2, limits2[1], limits2[2])
z3 <- runif(n3, limits3[1], limits3[2])
Z <- matrix(sort(c(z1, z2, z3)), n, 1)
# create precision matrices
# the shared part of the structure for all three intervals is a 2 on the
# diagonal and a 1 in the (2, 3) position
common_str <- diag(p + 1)
common_str[2, 3] <- 1
# define constants for the structure of interval 2
beta1 <- diff(limits2)^-1
beta0 <- -limits2[1] * beta1
# interval 2 has two different linear functions of Z in the (1, 2) position
# and (1, 3) positions; define structures for each of these components
int2_str12 <- int2_str13 <- matrix(0, p + 1, p + 1)
int2_str12[1, 2] <- int2_str13[1, 3] <- 1
# define the precision matrices for each of the individuals in interval 2
int2_prec <- lapply(z2, function(z) common_str +
((1 - beta0 - beta1*z)*int2_str12) +
((beta0 + beta1*z)*int2_str13))
# interval 1 has a 1 in the (1, 2) and interval 3 has a 1 in the (1, 3) position;
# define structures for each of these components
int1_str12 <- int3_str13 <- matrix(0, p + 1, p + 1)
int1_str12[1, 2] <- int3_str13[1, 3] <- 1
# define the precision matrices for each of the individuals in interval 1 and interval 3
int1_prec <- rep(list(common_str + int1_str12), n1)
int3_prec <- rep(list(common_str + int3_str13), n3)
# put all of the precision matrices into one list
prec_mats <- c(int1_prec, int2_prec, int3_prec)
# symmetrize the precision matrices
prec_mats <- lapply(prec_mats, function(mat) t(mat) + mat)
# invert the precision matrices to get the covariance matrices
cov_mats <- lapply(prec_mats, solve)
# generate the data using the covariance matrices
data_mat <- t(sapply(cov_mats, MASS::mvrnorm, n = 1, mu = rep(0, p + 1)))
return(list(data = data_mat, covts = Z, true_precision = prec_mats))
}
library(covdepGE)
library(latex2exp)
library(ggpubr)
library(tidyverse)
# colors for plots
set.seed(1)
colors <- c("chartreuse3", "chocolate2", "cornflowerblue", "darkgoldenrod1",
"darkmagenta", "deepskyblue3", "forestgreen", "darkorchid3",
"darkred", "darkslategray")
colors <- c(colors, sample(colors()[sapply(colors(), function(color)
!(substr(color, 1, 4)) %in% c("grey", "gray"))], 180))
cont <- generate_continuous(p = 25)
X <- cont$data
Z <- cont$covts
n <- nrow(X)
p <- ncol(X) - 1
interval <- c(rep(1, 60), rep(2, 60), rep(3, 60))
cov_df <- cbind.data.frame(interval = interval, Z, individual_index = 1:n)
cov_df$interval <- factor(cov_df$interval)
ggplot(cov_df, aes(Z, fill = interval)) +
geom_histogram(color = "black", binwidth = 0.2) +
theme_classic() +
ggsci::scale_fill_jco() +
labs(title = ("Distribution of Covariate")) +
theme(plot.title = element_text(hjust = 0.5))
# get the true graphs
true_graphs <- lapply(cont$true_precision, function(prec_mat) (prec_mat - diag(diag(prec_mat)) != 0) * 1)
# get the unique true graphs
strs <- unique(true_graphs)
# get the individual indices corresponding to each of the structures
ind_idx <- lapply(strs, function(strc) which(sapply(true_graphs, identical, strc)))
# get the summary for each
ind_sum <- sapply(ind_idx, function(idx) paste0(min(idx), ",...,", max(idx)))
# visualize each of the structures
str_viz <- lapply(1:length(strs), function(strc_idx)
gg_adjMat(strs[[strc_idx]], color1 = colors[strc_idx]) +
ggtitle(paste("Individuals ", ind_sum[strc_idx])))
ggarrange(plotlist = str_viz)
cond_nums
cond_num_fig <- ggplot(cov_df, aes(individual_index, cond_nums, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Condition Number")) +
theme(plot.title = element_text(hjust = 0.5))
cond_num_fig
cbind.data.frame(cov_df, cond_nums = cond_nums)
# visualize condition numbers and bandwidths
cond_nums <- lapply((blown_vars), function(idx) sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p))))
cond_num_fig <- ggplot(cbind.data.frame(cov_df, cond_nums = cond_nums[[1]]), aes(individual_index, cond_nums, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Condition Number")) +
theme(plot.title = element_text(hjust = 0.5))
cond_num_fig
cond_num_fig <- ggplot(cbind.data.frame(cov_df, cond_nums = cond_nums[[2]]), aes(individual_index, cond_nums, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Condition Number")) +
theme(plot.title = element_text(hjust = 0.5))
cond_num_fig
cond_num_fig <- lapply(cond_nums, function(cond_nums) ggplot(cbind.data.frame(cov_df, cond_nums = cond_nums), aes(individual_index, cond_nums, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Condition Number")) +
theme(plot.title = element_text(hjust = 0.5)))
cond_num_fig
bandwidth_fig <- ggplot(cov_df, aes(individual_index, bandwidths, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Bandwidths")) +
theme(plot.title = element_text(hjust = 0.5))
bandwidth_fig
cov_df$bandwidths <- out$bandwidths
bandwidth_fig <- ggplot(cov_df, aes(individual_index, bandwidths, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Bandwidths")) +
theme(plot.title = element_text(hjust = 0.5))
bandwidth_fig
library(covdepGE)
setwd("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/dev")
rm(list = ls())
source("generate_data.R")
R_code <- F # true if R code instead of C++ should be used
MAPE_upd <- F # true if MAPE updates for variance hyperparameters should be used
package <- T # true if the package version is desired
discrete_data <- T # true if discrete example is desired
# generate data and covariates
if (discrete_data) {
dat <- generate_discrete()
tau_ <- 0.1 # the bandwidth parameter
}else{
dat <- generate_continuous()
tau_ <- 0.56
}
data_mat <- dat$data
Z <- dat$covts
if (package){
if (MAPE_upd){
out <- covdepGE::covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
max_iter = 10, warnings = F)
}else{
out <- covdepGE::covdepGE(data_mat, Z, tau_, kde = F, CS = T, scale = F,
sigmabetasq_vec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10),
update_sigmasq = F, R = R_code, max_iter = 100,
warnings = F)
}
}else{
if ("covdepGE" %in% .packages()) detach("package:covdepGE", unload = TRUE)
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_main.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/cavi_search.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/weights.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/checks.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/gg_covdepGE.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_R.R")
Rcpp::sourceCpp("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/src/covdepGE_c.cpp")
if (MAPE_upd){
out <- covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
max_iter = 10, warnings = F)
}else{
out <- covdepGE(data_mat, Z, tau_, kde = F, CS = T, scale = F,
sigmabetasq_vec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10),
update_sigmasq = F, R = R_code,
max_iter = 100, warnings = F)
}
}
# check to see that this modified code produces the same results as the original code
if (discrete_data){
load("out_original_discrete.Rdata")
}else{
load("out_original_continuous.Rdata")
}
# check for equality between the alpha matrices
same_alpha <- T
total_diff <- 0
for (j in 1:length(out$alpha_matrices)) {
if (all.equal(out$alpha_matrices[[j]],
out_original$original_alpha_matrices[[j]]) != T) {
total_diff <- total_diff + norm(out$alpha_matrices[[j]] -
out_original$original_alpha_matrices[[j]], "F")
same_alpha <- F
}
}
total_diff
same_alpha
# check for equality between the inclusion probabilities
same_probs <- T
total_diff <- 0
for (j in 1:length(out$inclusion_probs)) {
if (all.equal(out$inclusion_probs[[j]],
out_original$original_incl_probs[[j]]) != T) {
same_probs <- F
total_diff <- total_diff + norm(out$inclusion_probs[[j]] -
out_original$original_incl_probs[[j]], "F")
}
}
total_diff
same_probs
# check for equality between ELBO
all.equal(unname(unlist(lapply(out$CAVI_details, `[[`, "ELBO"))), out_original$original_ELBO)
# check for equality with original hyperparameter update results
# original results generated with:
# out <- covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
#                 max_iter_grid = 10, max_iter_final = 10, warnings = F)
load("pi_stability_MAPE_orig.Rda")
sum(sapply(1:length(out$inclusion_probs), function(
j) sum((out$alpha_matrices[[j]] - out_orig$alpha_matrices[[j]])^2))) < 1e-10
sum(sapply(1:length(out$inclusion_probs), function(
j) sum((out$inclusion_probs[[j]] - out_orig$inclusion_probs[[j]])^2))) < 1e-10
# plot(out, title_sum = T)
setwd("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/dev")
rm(list = ls())
source("generate_data.R")
R_code <- F # true if R code instead of C++ should be used
MAPE_upd <- F # true if MAPE updates for variance hyperparameters should be used
package <- T # true if the package version is desired
discrete_data <- F # true if discrete example is desired
# generate data and covariates
if (discrete_data) {
dat <- generate_discrete()
tau_ <- 0.1 # the bandwidth parameter
}else{
dat <- generate_continuous()
tau_ <- 0.56
}
data_mat <- dat$data
Z <- dat$covts
if (package){
if (MAPE_upd){
out <- covdepGE::covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
max_iter = 10, warnings = F)
}else{
out <- covdepGE::covdepGE(data_mat, Z, tau_, kde = F, CS = T, scale = F,
sigmabetasq_vec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10),
update_sigmasq = F, R = R_code, max_iter = 100,
warnings = F)
}
}else{
if ("covdepGE" %in% .packages()) detach("package:covdepGE", unload = TRUE)
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_main.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/cavi_search.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/weights.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/checks.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/gg_covdepGE.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_R.R")
Rcpp::sourceCpp("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/src/covdepGE_c.cpp")
if (MAPE_upd){
out <- covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
max_iter = 10, warnings = F)
}else{
out <- covdepGE(data_mat, Z, tau_, kde = F, CS = T, scale = F,
sigmabetasq_vec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10),
update_sigmasq = F, R = R_code,
max_iter = 100, warnings = F)
}
}
# check to see that this modified code produces the same results as the original code
if (discrete_data){
load("out_original_discrete.Rdata")
}else{
load("out_original_continuous.Rdata")
}
# check for equality between the alpha matrices
same_alpha <- T
total_diff <- 0
for (j in 1:length(out$alpha_matrices)) {
if (all.equal(out$alpha_matrices[[j]],
out_original$original_alpha_matrices[[j]]) != T) {
total_diff <- total_diff + norm(out$alpha_matrices[[j]] -
out_original$original_alpha_matrices[[j]], "F")
same_alpha <- F
}
}
total_diff
same_alpha
# check for equality between the inclusion probabilities
same_probs <- T
total_diff <- 0
for (j in 1:length(out$inclusion_probs)) {
if (all.equal(out$inclusion_probs[[j]],
out_original$original_incl_probs[[j]]) != T) {
same_probs <- F
total_diff <- total_diff + norm(out$inclusion_probs[[j]] -
out_original$original_incl_probs[[j]], "F")
}
}
total_diff
same_probs
# check for equality between ELBO
all.equal(unname(unlist(lapply(out$CAVI_details, `[[`, "ELBO"))), out_original$original_ELBO)
# check for equality with original hyperparameter update results
# original results generated with:
# out <- covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
#                 max_iter_grid = 10, max_iter_final = 10, warnings = F)
load("pi_stability_MAPE_orig.Rda")
sum(sapply(1:length(out$inclusion_probs), function(
j) sum((out$alpha_matrices[[j]] - out_orig$alpha_matrices[[j]])^2))) < 1e-10
sum(sapply(1:length(out$inclusion_probs), function(
j) sum((out$inclusion_probs[[j]] - out_orig$inclusion_probs[[j]])^2))) < 1e-10
# plot(out, title_sum = T)
out
setwd("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/dev")
rm(list = ls())
source("generate_data.R")
R_code <- F # true if R code instead of C++ should be used
MAPE_upd <- T # true if MAPE updates for variance hyperparameters should be used
package <- T # true if the package version is desired
discrete_data <- F # true if discrete example is desired
# generate data and covariates
if (discrete_data) {
dat <- generate_discrete()
tau_ <- 0.1 # the bandwidth parameter
}else{
dat <- generate_continuous()
tau_ <- 0.56
}
data_mat <- dat$data
Z <- dat$covts
if (package){
if (MAPE_upd){
out <- covdepGE::covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
max_iter = 10, warnings = F)
}else{
out <- covdepGE::covdepGE(data_mat, Z, tau_, kde = F, CS = T, scale = F,
sigmabetasq_vec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10),
update_sigmasq = F, R = R_code, max_iter = 100,
warnings = F)
}
}else{
if ("covdepGE" %in% .packages()) detach("package:covdepGE", unload = TRUE)
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_main.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/cavi_search.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/weights.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/checks.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/gg_covdepGE.R")
source("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/R/covdepGE_R.R")
Rcpp::sourceCpp("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/src/covdepGE_c.cpp")
if (MAPE_upd){
out <- covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
max_iter = 10, warnings = F)
}else{
out <- covdepGE(data_mat, Z, tau_, kde = F, CS = T, scale = F,
sigmabetasq_vec = c(0.01, 0.05, 0.1, 0.5, 1, 3, 7, 10),
update_sigmasq = F, R = R_code,
max_iter = 100, warnings = F)
}
}
# check to see that this modified code produces the same results as the original code
if (discrete_data){
load("out_original_discrete.Rdata")
}else{
load("out_original_continuous.Rdata")
}
# check for equality between the alpha matrices
same_alpha <- T
total_diff <- 0
for (j in 1:length(out$alpha_matrices)) {
if (all.equal(out$alpha_matrices[[j]],
out_original$original_alpha_matrices[[j]]) != T) {
total_diff <- total_diff + norm(out$alpha_matrices[[j]] -
out_original$original_alpha_matrices[[j]], "F")
same_alpha <- F
}
}
total_diff
same_alpha
# check for equality between the inclusion probabilities
same_probs <- T
total_diff <- 0
for (j in 1:length(out$inclusion_probs)) {
if (all.equal(out$inclusion_probs[[j]],
out_original$original_incl_probs[[j]]) != T) {
same_probs <- F
total_diff <- total_diff + norm(out$inclusion_probs[[j]] -
out_original$original_incl_probs[[j]], "F")
}
}
total_diff
same_probs
# check for equality between ELBO
all.equal(unname(unlist(lapply(out$CAVI_details, `[[`, "ELBO"))), out_original$original_ELBO)
# check for equality with original hyperparameter update results
# original results generated with:
# out <- covdepGE(data_mat, Z, tau_, kde = F, scale = F, R = R_code,
#                 max_iter_grid = 10, max_iter_final = 10, warnings = F)
load("pi_stability_MAPE_orig.Rda")
sum(sapply(1:length(out$inclusion_probs), function(
j) sum((out$alpha_matrices[[j]] - out_orig$alpha_matrices[[j]])^2))) < 1e-10
sum(sapply(1:length(out$inclusion_probs), function(
j) sum((out$inclusion_probs[[j]] - out_orig$inclusion_probs[[j]])^2))) < 1e-10
# plot(out, title_sum = T)
plot(out, title_sum = T)
n_trials <- 1
results <- vector("list", n_trials)
names(results) <- paste0("trial", 1:n_trials)
doParallel::registerDoParallel(15)
for (j in 1:n_trials){
# generate the data
cont <- generate_continuous(p = 25)
X <- cont$data
Z <- cont$covts
# run the algorithm
out <- covdepGE(X, Z, max_iter = 1e3, parallel = T, warnings = F, stop_cluster = F)
# which of the sigmas blew up?
blown_sigs <- out$hyperparameters$sigmasq > 10 | is.na(out$hyperparameters$sigmasq)
# find the total number of blownup sigmas per variable
blown_by_var <- colSums(blown_sigs)
# which variables have at least one blown up sigma?
blown_vars <- which(blown_by_var > 0)
# find the blown up counts that are greater than 0
blown0_ct <- blown_by_var[blown_vars]
# find the individual indices corresponding to the blown up sigmas
blown_inds <- apply(blown_sigs[ , blown_vars, drop = F], 2, which)
# visualize condition numbers and bandwidths
cond_nums <- lapply((blown_vars), function(idx) sapply(1:180, function(j) kappa(X[ , -idx] * matrix(out$weights[ , j]^0.5, n ,p))))
cov_df$bandwidths <- out$bandwidths
cond_num_fig <- lapply(cond_nums, function(cond_nums)
ggplot(cbind.data.frame(cov_df, cond_nums = cond_nums), aes(individual_index, cond_nums, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Condition Number")) +
theme(plot.title = element_text(hjust = 0.5)))
bandwidth_fig <- ggplot(cov_df, aes(individual_index, bandwidths, color = interval)) +
geom_line(size = 1) +
theme_classic() +
ggsci::scale_color_jco() +
labs(title = ("Bandwidths")) +
theme(plot.title = element_text(hjust = 0.5))
results[[j]] <- list(summary = out, sigma_blowup_by_individual = blown_inds, condition_numbers = cond_num_fig,
bandwidths = bandwidth_fig)
}
out
ls()
setdiff(ls(), "generate_continuous")
rm(list = setdiff(ls(), "generate_continuous"))
ls()
rm(list = setdiff(ls(), c("generate_continuous", "cov_df")))
load("~/TAMU/Research/An approximate Bayesian approach to covariate dependent/covdepGE/dev/analyses_demos_experiments/hyperparameter_specification/condition_number_analysis/cond_number_models.Rda")
